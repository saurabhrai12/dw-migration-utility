"""
Report generator utility for creating migration reports.
"""
import json
from pathlib import Path
from typing import Any, Dict, List
from datetime import datetime
from jinja2 import Environment, FileSystemLoader, Template
import markdown
from loguru import logger


class ReportGenerator:
    """Generate various migration reports."""

    def __init__(self, output_dir: str = "output/mapping_docs"):
        """
        Initialize report generator.

        Args:
            output_dir: Directory to save reports
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def generate_migration_summary(
        self,
        total_tables: int,
        mapped_tables: int,
        unmapped_tables: List[str],
        procedures_generated: int,
        validation_results: Dict[str, Any]
    ) -> str:
        """
        Generate migration summary report.

        Args:
            total_tables: Total number of tables processed
            mapped_tables: Number of successfully mapped tables
            unmapped_tables: List of unmapped table names
            procedures_generated: Number of stored procedures generated
            validation_results: Validation results dictionary

        Returns:
            Path to generated report
        """
        report_content = f"""# Data Warehouse Migration Summary Report

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Overview

- **Total Tables Processed:** {total_tables}
- **Successfully Mapped:** {mapped_tables} ({mapped_tables/total_tables*100:.1f}%)
- **Unmapped Tables:** {len(unmapped_tables)}
- **Stored Procedures Generated:** {procedures_generated}

## Mapping Statistics

### Successfully Mapped Tables
{mapped_tables} tables were successfully mapped from Oracle to Snowflake.

### Unmapped Tables
The following tables require manual intervention:

"""
        if unmapped_tables:
            for table in unmapped_tables:
                report_content += f"- {table}\n"
        else:
            report_content += "*No unmapped tables*\n"

        report_content += f"""

## Validation Results

- **Row Count Validation:** {'Passed' if validation_results.get('row_count_match', False) else 'Failed'}
- **Data Quality Checks:** {'Passed' if validation_results.get('data_quality_pass', False) else 'Failed'}
- **Schema Validation:** {'Passed' if validation_results.get('schema_valid', False) else 'Failed'}

## Next Steps

1. Review unmapped tables and create manual mappings
2. Test generated stored procedures in development environment
3. Validate data accuracy with business stakeholders
4. Plan deployment schedule for production migration

---
*Generated by Data Warehouse Migration Utility*
"""

        output_path = self.output_dir / f"migration_summary_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        with open(output_path, 'w') as f:
            f.write(report_content)

        logger.info(f"Migration summary report generated: {output_path}")
        return str(output_path)

    def generate_mapping_documentation(
        self,
        table_mappings: List[Dict[str, Any]],
        column_mappings: List[Dict[str, Any]]
    ) -> str:
        """
        Generate detailed mapping documentation.

        Args:
            table_mappings: List of table mapping dictionaries
            column_mappings: List of column mapping dictionaries

        Returns:
            Path to generated documentation
        """
        report_content = f"""# Table and Column Mapping Documentation

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Table Mappings

| Oracle Schema | Oracle Table | Snowflake Database | Snowflake Schema | Snowflake Table | Match Type |
|---------------|--------------|-------------------|------------------|-----------------|------------|
"""

        for mapping in table_mappings:
            report_content += f"| {mapping.get('oracle_schema', '')} | {mapping.get('oracle_table', '')} | {mapping.get('snowflake_database', '')} | {mapping.get('snowflake_schema', '')} | {mapping.get('snowflake_table', '')} | {mapping.get('match_type', '')} |\n"

        report_content += "\n## Column Mappings\n\n"

        # Group column mappings by table
        tables = {}
        for col_map in column_mappings:
            table_key = f"{col_map.get('oracle_schema')}.{col_map.get('oracle_table')}"
            if table_key not in tables:
                tables[table_key] = []
            tables[table_key].append(col_map)

        for table_key, columns in tables.items():
            report_content += f"### {table_key}\n\n"
            report_content += "| Oracle Column | Data Type | Snowflake Column | Data Type | Transformation |\n"
            report_content += "|---------------|-----------|------------------|-----------|----------------|\n"

            for col in columns:
                transformation = col.get('transformation', 'Direct mapping')
                report_content += f"| {col.get('oracle_column', '')} | {col.get('oracle_type', '')} | {col.get('snowflake_column', '')} | {col.get('snowflake_type', '')} | {transformation} |\n"

            report_content += "\n"

        output_path = self.output_dir / f"mapping_documentation_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        with open(output_path, 'w') as f:
            f.write(report_content)

        logger.info(f"Mapping documentation generated: {output_path}")
        return str(output_path)

    def generate_validation_report(
        self,
        validations: List[Dict[str, Any]]
    ) -> str:
        """
        Generate validation report.

        Args:
            validations: List of validation result dictionaries

        Returns:
            Path to generated report
        """
        passed = sum(1 for v in validations if v.get('status') == 'PASSED')
        failed = sum(1 for v in validations if v.get('status') == 'FAILED')

        report_content = f"""# Data Validation Report

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Summary

- **Total Validations:** {len(validations)}
- **Passed:** {passed} ({passed/len(validations)*100:.1f}%)
- **Failed:** {failed} ({failed/len(validations)*100:.1f}%)

## Validation Details

| Table | Validation Type | Oracle Count | Snowflake Count | Status | Notes |
|-------|----------------|--------------|-----------------|--------|-------|
"""

        for val in validations:
            report_content += f"| {val.get('table', '')} | {val.get('validation_type', '')} | {val.get('oracle_count', '')} | {val.get('snowflake_count', '')} | {val.get('status', '')} | {val.get('notes', '')} |\n"

        report_content += """

## Recommendations

"""
        if failed > 0:
            report_content += f"- Investigate {failed} failed validation(s)\n"
            report_content += "- Review transformation logic for discrepancies\n"
            report_content += "- Validate data types and constraints\n"
        else:
            report_content += "- All validations passed successfully\n"
            report_content += "- Proceed with next phase of migration\n"

        output_path = self.output_dir / f"validation_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        with open(output_path, 'w') as f:
            f.write(report_content)

        # Also save JSON version for programmatic access
        json_path = self.output_dir / f"validation_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(json_path, 'w') as f:
            json.dump(validations, f, indent=2)

        logger.info(f"Validation report generated: {output_path}")
        return str(output_path)

    def generate_lineage_documentation(
        self,
        lineage_data: Dict[str, Any]
    ) -> str:
        """
        Generate data lineage documentation.

        Args:
            lineage_data: Data lineage information

        Returns:
            Path to generated documentation
        """
        report_content = f"""# Data Lineage Documentation

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Overview

This document traces data lineage from Oracle source tables through Informatica transformations to Snowflake target tables.

"""

        for target_table, lineage in lineage_data.items():
            report_content += f"## Target Table: {target_table}\n\n"

            # Source tables
            if 'sources' in lineage:
                report_content += "### Source Tables\n\n"
                for source in lineage['sources']:
                    report_content += f"- **{source.get('schema')}.{source.get('table')}**\n"
                    if source.get('columns'):
                        report_content += "  - Columns: " + ", ".join(source['columns']) + "\n"
                report_content += "\n"

            # Transformations
            if 'transformations' in lineage:
                report_content += "### Transformations Applied\n\n"
                for idx, transform in enumerate(lineage['transformations'], 1):
                    report_content += f"{idx}. **{transform.get('type')}**: {transform.get('description', '')}\n"
                    if transform.get('logic'):
                        report_content += f"   - Logic: `{transform['logic']}`\n"
                report_content += "\n"

            # Target columns
            if 'target_columns' in lineage:
                report_content += "### Target Columns\n\n"
                report_content += "| Column | Source | Transformation |\n"
                report_content += "|--------|--------|----------------|\n"
                for col in lineage['target_columns']:
                    report_content += f"| {col.get('name')} | {col.get('source', '')} | {col.get('transformation', '')} |\n"
                report_content += "\n"

        output_path = self.output_dir / f"lineage_documentation_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        with open(output_path, 'w') as f:
            f.write(report_content)

        logger.info(f"Lineage documentation generated: {output_path}")
        return str(output_path)

    def convert_to_html(self, markdown_path: str) -> str:
        """
        Convert markdown report to HTML.

        Args:
            markdown_path: Path to markdown file

        Returns:
            Path to generated HTML file
        """
        with open(markdown_path, 'r') as f:
            md_content = f.read()

        html_content = markdown.markdown(md_content, extensions=['tables', 'fenced_code'])

        # Wrap in basic HTML template
        full_html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Migration Report</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }}
        table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}
        th, td {{ border: 1px solid #ddd; padding: 12px; text-align: left; }}
        th {{ background-color: #4CAF50; color: white; }}
        tr:nth-child(even) {{ background-color: #f2f2f2; }}
        code {{ background-color: #f4f4f4; padding: 2px 6px; border-radius: 3px; }}
        h1 {{ color: #333; }}
        h2 {{ color: #666; border-bottom: 2px solid #4CAF50; padding-bottom: 5px; }}
    </style>
</head>
<body>
{html_content}
</body>
</html>"""

        html_path = Path(markdown_path).with_suffix('.html')
        with open(html_path, 'w') as f:
            f.write(full_html)

        logger.info(f"HTML report generated: {html_path}")
        return str(html_path)
